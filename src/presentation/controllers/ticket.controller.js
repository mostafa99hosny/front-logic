const path = require("path");
const fs = require("fs");
const Ticket = require('../../infrastructure/models/ticket.model');

// Create a new ticket
const createTicket = async (req, res) => {
  try {
    const { subject, classification, description } = req.body;

    // Handle file attachments if any
    let attachments = [];
    if (req.files && req.files.length > 0) {
      attachments = req.files.map(file => ({
        filename: file.filename,        // unique filename generated by multer
        originalName: file.originalname, // keep original name for display
        path: file.path,
        mimetype: file.mimetype,
        size: file.size
      }));
    }

    const newTicket = new Ticket({
      subject,
      classification,
      description,
      attachments,
      createdBy: req.user.userId // Link ticket to user
    });

    const savedTicket = await newTicket.save();

    res.status(201).json({
      success: true,
      message: 'Ticket created successfully',
      ticket: savedTicket
    });
  } catch (error) {
    console.error('Error creating ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create ticket',
      error: error.message
    });
  }
};

// Get all tickets
const getAllTickets = async (req, res) => {
  try {
    let tickets;
    const adminEmails = ["super.admin@gmail.com", "admin.tickets@gmail.com"];
    const isPrivileged = adminEmails.includes((req.user.email || "").toLowerCase());
    if (isPrivileged) {
      tickets = await Ticket.find().populate('createdBy', 'firstName lastName email company').sort({ createdAt: -1 });
    } else {
      tickets = await Ticket.find({ createdBy: req.user.userId }).populate('createdBy', 'firstName lastName email company').sort({ createdAt: -1 });
    }
    res.status(200).json({
      success: true,
      tickets
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to fetch tickets',
      error: error.message
    });
  }
};

// Get single ticket by ID
const getTicketById = async (req, res) => {
  try {
    const ticket = await Ticket.findById(req.params.id).populate('createdBy', 'firstName lastName');

    if (!ticket) {
      return res.status(404).json({
        success: false,
        message: 'Ticket not found'
      });
    }

    res.status(200).json({
      success: true,
      ticket
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to fetch ticket',
      error: error.message
    });
  }
};

// Update ticket status
const updateTicketStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status, priority, classification } = req.body;

    const ticket = await Ticket.findById(id);
    if (!ticket) {
      return res.status(404).json({ success: false, message: 'Ticket not found' });
    }

    // Check if user is authorized (ticket creator or support/super admin)
    const adminEmails = ["super.admin@gmail.com", "admin.tickets@gmail.com"];
    const isPrivileged = adminEmails.includes((req.user.email || "").toLowerCase());
    if (!isPrivileged && ticket.createdBy.toString() !== req.user.userId) {
      return res.status(403).json({ success: false, message: 'Unauthorized' });
    }

    // Update fields
    if (status) ticket.status = status;
    if (priority !== undefined) ticket.priority = priority;
    if (classification) ticket.classification = classification;
    ticket.updatedAt = new Date();

    await ticket.save();

    res.status(200).json({
      success: true,
      message: 'Ticket updated successfully',
      ticket
    });
  } catch (error) {
    console.error('Error updating ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update ticket',
      error: error.message
    });
  }
};

// Rate ticket
const rateTicket = async (req, res) => {
  try {
    const { id } = req.params;
    const { rating, comment } = req.body;

    const ticket = await Ticket.findById(id);
    if (!ticket) {
      return res.status(404).json({ success: false, message: 'Ticket not found' });
    }

    // Check if user is the ticket creator
    if (ticket.createdBy.toString() !== req.user.userId) {
      return res.status(403).json({ success: false, message: 'Unauthorized' });
    }

    // Check if ticket is closed
    if (ticket.status !== 'closed') {
      return res.status(400).json({ success: false, message: 'Can only rate closed tickets' });
    }

    // Check if already rated
    if (ticket.rating) {
      return res.status(400).json({ success: false, message: 'Ticket already rated' });
    }

    // Validate rating
    if (!rating || rating < 1 || rating > 5) {
      return res.status(400).json({ success: false, message: 'Rating must be between 1 and 5' });
    }

    ticket.rating = rating;
    ticket.ratingComment = comment || '';
    ticket.ratedAt = new Date();
    ticket.updatedAt = new Date();

    await ticket.save();

    res.status(200).json({
      success: true,
      message: 'Ticket rated successfully',
      ticket
    });
  } catch (error) {
    console.error('Error rating ticket:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to rate ticket',
      error: error.message
    });
  }
};

// Download ticket attachment
const downloadAttachment = async (req, res) => {
  try {
    const { ticketId, filename } = req.params;

    const ticket = await Ticket.findById(ticketId);
    if (!ticket) {
      return res.status(404).json({ success: false, message: "Ticket not found" });
    }

    const file = ticket.attachments.find(att => att.filename === filename);
    if (!file) {
      return res.status(404).json({ success: false, message: "File not found in ticket" });
    }

    const filePath = path.resolve(file.path);
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ success: false, message: "File not found on server" });
    }

    res.download(filePath, file.originalName || file.filename);
  } catch (error) {
    console.error("Error downloading file:", error);
    res.status(500).json({ success: false, message: "Failed to download file" });
  }
};

module.exports = {
  createTicket,
  getAllTickets,
  getTicketById,
  updateTicketStatus,
  rateTicket,
  downloadAttachment
};
